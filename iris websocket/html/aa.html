<!DOCTYPE html>
<html lang="zh-CN">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>index</title>
		<!-- Bootstrap -->
		<script src="https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"></script>
		<!-- 最新版本的 Bootstrap 核心 CSS 文件 -->
		<link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

		<!-- 可选的 Bootstrap 主题文件（一般不用引入） -->
		<link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

		<!-- 最新的 Bootstrap 核心 JavaScript 文件 -->
		<script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
		<style type="text/css">
			body{ font-family: Microsoft YaHei,'宋体' , Tahoma, Helvetica, Arial, "\5b8b\4f53", sans-serif;}
		</style>
		<script src="https://cdn.bootcss.com/markdown.js/0.6.0-beta1/markdown.min.js"></script>
	</head>
	<body>
        <nav id="navbar-example" class="navbar navbar-default navbar-static" role="navigation">
                <div class="container-fluid"> 
                    <div class="navbar-header">
                        <button class="navbar-toggle" type="button" data-toggle="collapse" 
                                data-target=".bs-js-navbar-scrollspy">
                            <span class="sr-only">切换导航</span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </button>
                        <a class="navbar-brand" href="#">Web开发学习笔记</a>
                    </div>
                    <div class="collapse navbar-collapse bs-js-navbar-scrollspy">
                        <ul class="nav navbar-nav">
                            <li><a href="">后台 <!--<span class="sr-only">(current)</span>--></a></li>
                            <li><a href="#go">golang与iris框架</a></li>
                            <li><a href="#Spring">Spring</a></li>
                            <li><a href="#Hibernate">Hibernate</a></li>
                            <li><a href="#Struts2">Struts2</a></li>
                            <li><a href="#ELJSTL">EL及JSTL</a></li>
                            <li><a href="#AJAX">AJAX</a></li>
                            <li><a href="#BootStrap">栅格与响应式</a></li>
                            <li><a href="#websocket">websocket与netty框架</a></li>
                        </ul>
                        <form class="navbar-form navbar-left">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search">
                            </div>
                            <button type="submit" class="btn btn-default">Submit</button>
                        </form>
                        <ul class="nav navbar-nav navbar-right">
                            <li><a href="#">注册</a></li>
                            <li><a href="#">登录</a></li>
                        </ul>
                    </div>
                </div> 
            </nav>
            <div class="cow">
                <div class="col-md-2 col-lg-2 col-sm-1 col-xs-1"></div>
            <div data-spy="scroll" data-target="#navbar-example" data-offset="0" 
                    style="height:800px;overflow:auto; position: relative;" class="col-md-8 col-lg-8 col-sm-10 col-xs-10">
                    <div>
                        <h3 id="go">GoLang与IRIS框架</h3>
                        <div>
<h3>Go IRIS框架学习笔记</h2>

    <blockquote>
        <p>当前网上关于Golang的IRIS框架的教程极极极极少，有参考价值的也就官方文档，</p>
        <p>可惜官网文档<strong>除 了 代 码 什 么 都 没 有</strong>，而且 还 <strong>没 有 中 文 版</strong>，竟 然 还 是 <strong>按 照 首 字 母 排 得 序</strong>，</p>
        <p>但是比起热门的GIN、BEEGO、马卡龙框架，IRIS还是有自己的特点的，于是在此整理方便学习和以后使用（以官方文档为主）  []内内容为备注(类型) [...]为方法</p>
    </blockquote>
<h4>安装iris和导入iris</h4>
<pre>
命令行:go get github.com/kataras/iris
</pre>
<pre>
import (
    "github.com/kataras/iris"
)
</pre>
<h4> 生成网页与注册路由的一般方法</h4>
<ul>
<li><h5>main函数中</h5></li>
<pre>
app.RegisterView(iris.HTML("/html[directory]",".html[extension]").Reload(true))
app.StaticWeb("/js[request path]", "./js[system path]") // serve our custom javascript code
app.Get("/",index[funcName])  //路由
app.Run(iris.Addr(":80"))  //端口
</pre>
<li><h5>路由函数中</h5></li>
<pre>
func funcName(ctx iris.Context){
    if err := ctx.View("index.html");err!=nil {
            //错误处理[...]
    }
}
</pre>
<li><h5>错误页面</h5></li>
<pre>
app.OnErrorCode(iris.StatusNotFound, func(ctx iris.Context){
        ctx.View("404.html")
})
</pre>
</ul>
<h4> 读取POST请求和ORM基本操作</h4>
<pre>
type 表名 struct {
    Id       int64`pk`
    字段名   string`unique`
    Password string`notnull`
}
// 生成的表会自动转化格式 如 AdminUser → admin_user
// 下面例子假定表名为admin_user
func Funcname(ctx iris.Context) {
    user := AdminUser{}
    //  读取请求
    err := ctx.ReadForm(&user)
    if err !=nil {
        //[..]
    }
    //  ORM
    //  mysql
    orm,err := xorm.NewEngine("mysql", "用户名:密码@/库名?charset=utf8")
    //  不同数据库操作不同 具体参考文档
    if err != nil {
        app.Logger().Fatalf("orm failed to initialized: %v", err)
    }
    iris.RegisterOnInterrupt(func(){
        orm.Close()
    })
    err = orm.Sync2(new(AdminUser))
    if err != nil {
        app.Logger().Fatalf("orm failed to initialized User table: %v", err)
    }
    adminuser := AdminUser{Account: user.Account}
    //查找操作
    if ok, _ := orm.Get(&adminuser); ok { //orm.Id(xxx).Get(&) 或 orm.Where("属性=?",value).Get(&)
    } else {
    }
    //插入操作
    adminuser.Account = "AAAAAAA"
    orm.Insert(adminuser)
    //修改操作
    orm.Id(xx).Update(adminuser)
    //删除操作
    orm.delete(adminuser)
    //查找全部
    var users []AdminUser
    orm.Find(&users)
    //详细操作日后再来学习
    //官方文档http://www.xorm.io/docs/
}
</pre>

<h4>带参数的路径</h4>
<pre>
app.Get("/{xxx}/{namedRoute}", func(ctx iris.Context) {
        xxx := ctx.Params().Get("xxx")
        routeName := ctx.Params().Get("namedRoute")
        //[...]
})
</pre>
<h4> Ajax</h4>
<ul>
<li><h5>前端页面</h5></li>
<pre>
&lt;script src="https://code.jquery.com/jquery-3.1.1.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
    $(function() {
        $("#按钮Id").click(function() {
            //提交的参数
            var params = {
                Account : $("#input的Id").val(),
                Password : $("#input的Id").val()
            };
            $.post("/路由",params,function (参数) {
                要执行的func(参数);
        });
    });
&lt;/script&gt;
</pre>
<li><h5>Go</h5></li>
<pre>
//接收post
user := AdminUser{}
err := ctx.ReadForm(&user)
if err !=nil {
    ctx.StatusCode(iris.StatusInternalServerError)
    ctx.WriteString(err.Error())
    ctx.Redirect("/404")
}
//要执行的操作func(user)
ctx.WriteString(返回值)
return
</pre>
</ul>
<h4> session</h4>
<pre>
var (
    cookieNameForSessionID = "mycookiesessionnameid"
    sess                   = sessions.New(sessions.Config{Cookie: cookieNameForSessionID})
)
session := sess.Start(ctx)  //ctx iris.Context
session.Set（"key", value)
session.Get("key")  //若使用Get方法需要强转 指定：GetString GetInt GetBoolean GetAll GetFloat ...
session.Delete("key")   //删除
session.Clear()     //清空
session.Destroy()   //销毁
</pre>
<h4> WebSokect</h4>
<ul>
<li><h5>iris的websocket</h5></li>
    <ul>
    <li><h5>html</h5></li>
    <pre>
    &lt;form name = "form1" method="post"&gt;
        输入聊天信息:&lt;input id="msg" name="msg" type="text" size="40" class="form-control"&gt;
    &lt;/form&gt;
    &lt;button name="websocket" id="websocket" class="btn btn-default" onclick="send()"&gt;发送&lt;/button&gt;
    &lt;script src="/iris-ws.js"&gt;&lt;/script&gt;
    &lt;div id="message" name="message"&gt;&lt;/div&gt;
    
    </pre>
    <li><h5>js</h5></li>
    <pre>
    var scheme = document.location.protocol == "https:" ? "wss" : "ws";
    var port = document.location.port ? (":" + document.location.port) : "";
    // see app.Get("/echo", ws.Handler()) on main.go
    var wsURL = scheme + "://" + document.location.hostname + port+"/echo";
    var input = document.getElementById("msg");
    var output = document.getElementById("message");
    // Ws comes from the auto-served '/iris-ws.js'
    var socket = new Ws(wsURL)
    socket.OnConnect(function () {
        //连接服务器[...]
    });
    socket.OnDisconnect(function () {
        //无法连接服务器[...]
    });
    // read events from the server
    socket.On("消息名称", function (msg) {
        //读取事件[...]
        addMessage(msg+"&lt;br/&gt;");
    });
    function send() {
        addMessage("Me: " + input.value); // write ourselves
        socket.Emit("消息名称", "消息内容");// send chat event data to the websocket server
        input.value = ""; // clear the input
    }
    function addMessage(msg) {
        output.innerHTML += msg + "&lt;br&gt;";
    }
    </pre>
    <li><h5>Go</h5></li>
    <pre>
    package main

    import (
        "github.com/kataras/iris"
        "github.com/kataras/iris/websocket"
        "github.com/go-xorm/xorm"
    )
    
    func setupWebsocket(app *iris.Application) {
        // create our echo websocket server
        ws := websocket.New(websocket.Config{
            ReadBufferSize:  1024,
            WriteBufferSize: 1024,
        })
        ws.OnConnection(handleConnection)
        // register the server on an endpoint.
        app.Get("/echo", ws.Handler())
        // see html script tags, this path is used.
        app.Any("/iris-ws.js", func(ctx iris.Context) {
            ctx.Write(websocket.ClientSource)
        })
    }
    
    func handleConnection(c websocket.Connection) {
        c.On("chat", func(msg string) {
            // fmt.Printf("%s sent: %s\n", c.Context().RemoteAddr(), msg)
            // Write message back to the client message owner with: c.Emit("消息名称", msg)
            // 返回所有人 websocket.All
            // Write message to all except this client with:
            c.To(websocket.Broadcast).Emit("消息名称", msg)
        })
        c.OnDisconnect(func() {
            //断开连接操作[...]
        })
    }
    func main() {
        setupWebsocket(app)
    }
    </pre>
    </ul>
<li><h5>官方的websocket</h5></li>
<li><h5>第三方websocket</h5></li>
</ul>
<h4> 模板</h4>
<ul>
<li><h5>上下文视图数据</h5></li>
<pre>
app.Get("/路由", func(ctx iris.Context) {
        ctx.ViewData("Key", "Value")
        if err := ctx.View("index.html"); err != nil {
            //[...]
        }
})
//HTML中使用{{.Key}}获取
</pre>
<li><h5>嵌入模板</h5></li>
<pre>
//layout页面中加入{{ yield }}使用模板
//HTML中使用{{funcName 参数}}使用函数 如下例中可使用 {{ greet "string" }}
//{{ render "路径" }} 把别的html文件的内容拿过来
func main() {
    app := iris.New()
    //全局模板 所有页面适用
    tmpl := iris.HTML("./templates[html文件夹路径]", ".html")
    tmpl.Layout("layouts/layout.html[layout文件路径]")
    tmpl.AddFunc("greet", func(s string) string {
        //[..]
    })
    tmpl.Binary(Asset, AssetNames) // &lt;-<li><h5>IMPORTANT
    app.RegisterView(tmpl)
    app.Get("/", func(ctx iris.Context) {
        if err := ctx.View("page1.html"); err != nil {
            ctx.StatusCode(iris.StatusInternalServerError)
            ctx.Writef(err.Error())
        }
    })

    // 不使用全局模板
    app.Get("/nolayout", func(ctx iris.Context) {
        ctx.ViewLayout(iris.NoLayout)
        if err := ctx.View("page1.html"); err != nil {
            ctx.StatusCode(iris.StatusInternalServerError)
            ctx.Writef(err.Error())
        }
    })

    // 局部模板 不受全局模板影响
    my := app.Party("/my").Layout("layouts/mylayout.html") { 
        my.Get("/", func(ctx iris.Context) {
            ctx.View("page1.html")
        })
        my.Get("/other", func(ctx iris.Context) {
            ctx.View("page2.html")
        })
    }
    app.Run(iris.Addr(":8080"))
}
</pre>
<li><h5>hero</h5></li>
<ul>
    <li><h5>官方文档 https://github.com/shiyanhui/hero/blob/master/README_CN.md</h5></li>
    <li><h5>iris中的实现</h5></li>
        <p>1. HTML中编写模板（语法见下）</p>
        <p>2. 命令行中进入%GOPATH%/bin 执行hero -source="模板所在文件夹"</p>
        <p>3. main函数中</p>
        <pre>
        //对于&lt;%: func FuncName(变量名 []string, buffer *bytes.Buffer) %&gt;
        app.Get("/路由", func(ctx iris.Context) {
            var 变量名 = []string{
                //变量值
                //..
            }
            // Had better use buffer sync.Pool.
            // Hero exports GetBuffer and PutBuffer for this.
            //
            // buffer := hero.GetBuffer()
            // defer hero.PutBuffer(buffer)
            buffer := new(bytes.Buffer)
            template.FuncName(变量名, buffer)
            if _, err := ctx.Write(buffer.Bytes()); err != nil {
                log.Printf("ERR: %s\n", err)
            }
        })
        
        </pre>
        <pre>
        //对于&lt;%: func FuncName(变量名 []string, w io.Writer) (int, error)%&gt;
        app.Get("/路由", func(ctx iris.Context) {
            var 变量名 = []string{
                //
            }
            // using an io.Writer for automatic buffer management (i.e. hero built-in buffer pool),
            // iris context implements the io.Writer by its ResponseWriter
            // which is an enhanced version of the standard http.ResponseWriter
            // but still 100% compatible.
            template.UserListToWriter(FuncName, ctx)
        })
    </pre>
    <li><h5>以下内容转自官方文档</h5></li>
    <li><h5>Hero总共有九种语句，他们分别是：</h5></li>
    <li><h5>函数定义语句 <code>&lt;%: func define %&gt;</code></h5></li>
    <ul>
        <li><h5>该语句定义了该模板所对应的函数，如果一个模板中没有函数定义语句，那么最终结果不会生成对应的函数。</h5></li>
        <li><h5>该函数最后一个参数必须为<code>*bytes.Buffer</code>或者<code>io.Writer</code>, hero会自动识别该参数的名字，并把把结果写到该参数里。</h5></li>
        <li><h5>例:</h5></li>
            <ul>
        <li><h5><code>&lt;%: func UserList(userList []string, buffer *bytes.Buffer) %&gt;</code></h5></li>
        <li><h5><code>&lt;%: func UserList(userList []string, w io.Writer) %&gt;</code></h5></li>
        <li><h5><code>&lt;%: func UserList(userList []string, w io.Writer) (int, error) %&gt;</code></h5></li>
        </ul>
    </ul>
    <li><h5>模板继承语句 <code>&lt;%~ "parent template" %&gt;</code></h5></li>
        <li><h5>该语句声明要继承的模板。</h5></li>
        <li><h5>例: <code>&lt;%~ "index.html" &gt;</code></h5></li>
    
    <li><h5>模板include语句 <code>&lt;%+ "sub template" %&gt;</code></h5></li>
        <li><h5>该语句把要include的模板加载进该模板，工作原理和<code>C++</code>中的<code>#include</code>有点类似。</h5></li>
        <li><h5>例: <code>&lt;%+ "user.html" &gt;</code></h5></li>
    
    <li><h5>包导入语句 <code>&lt;%! go code %&gt;</code></h5></li>
        <li><h5>该语句用来声明所有在函数外的代码，包括依赖包导入、全局变量、const等。</h5></li>
    
        <li><h5>该语句不会被子模板所继承</h5></li>
    
        <li><h5>例:</h5></li>
    
        <pre>go
        &lt;%!
            import (
                    "fmt"
                "strings"
            )
    
            var a int
    
            const b = "hello, world"
    
            func Add(a, b int) int {
                return a + b
            }
    
            type S struct {
                Name string
            }
    
            func (s S) String() string {
                return s.Name
            }
        %&gt;
        </pre>
    
    <li><h5>块语句 <code>&lt;%@ blockName { %&gt; &lt;% } %&gt;</code></h5></li>
    
        <li><h5>块语句是用来在子模板中重写父模中的同名块，进而实现模板的继承。</h5></li>
    
        <li><h5>例:</h5></li>
    
        <pre>html
        &lt;!DOCTYPE html&gt;
        &lt;html&gt;
            &lt;head&gt;
                &lt;meta charset="utf-8"&gt;
            &lt;/head&gt;
    
            &lt;body&gt;
                &lt;%@ body { %&gt;
                &lt;% } %&gt;
            &lt;/body&gt;
        &lt;/html&gt;
        </pre>
    
    <li><h5>Go代码语句 <code>&lt;% go code %&gt;</code></h5></li>
    
        <li><h5>该语句定义了函数内部的代码部分。</h5></li>
    
        <li><h5>例:</h5></li>
    
        <pre>go
        &lt;% for _, user := userList { %&gt;
            &lt;% if user != "Alice" { %&gt;
                &lt;%= user %&gt;
            &lt;% } %&gt;
        &lt;% } %&gt;
    
        &lt;%
            a, b := 1, 2
            c := Add(a, b)
        %&gt;
        </pre>
    
    <li><h5>原生值语句 <code>&lt;%==[t] variable %&gt;</code></h5></li>
    
        <li><h5>该语句把变量转换为string。</h5></li>
    
        <li><h5><code>t</code>是变量的类型，hero会自动根据<code>t</code>来选择转换函数。<code>t</code>的待选值有:</h5></li>
        <li><h5><code>b</code>: bool</h5></li>
        <li><h5><code>i</code>: int, int8, int16, int32, int64</h5></li>
        <li><h5><code>u</code>: byte, uint, uint8, uint16, uint32, uint64</h5></li>
        <li><h5><code>f</code>: float32, float64</h5></li>
        <li><h5><code>s</code>: string</h5></li>
        <li><h5><code>bs</code>: []byte</h5></li>
        <li><h5><code>v</code>: interface</h5></li>
    
        注意：
        <li><h5>如果<code>t</code>没有设置，那么<code>t</code>默认为<code>s</code>.</h5></li>
        <li><h5>最好不要使用<code>v</code>，因为其对应的转换函数为<code>fmt.Sprintf("%v", variable)</code>，该函数很慢。</h5></li>
    
        <li><h5>例:</h5></li>
    
        <pre>go
        &lt;%== "hello" %&gt;
        &lt;%==i 34  %&gt;
        &lt;%==u Add(a, b) %&gt;
        &lt;%==s user.Name %&gt;
        </pre>
    
    <li><h5>转义值语句 <code>&lt;%= statement %&gt;</code></h5></li>
    
        <li><h5>该语句把变量转换为string后，又通过<code>html.EscapesString</code>记性转义。</h5></li>
        <li><h5><code>t</code>跟上面原生值语句中的<code>t</code>一样。</h5></li>
        <li><h5>例:</h5></li>
    
        <pre>go
        &lt;%= a %&gt;
        &lt;%= a + b %&gt;
        &lt;%= Add(a, b) %&gt;
        &lt;%= user.Name %&gt;
        </pre>
    <li><h5>注释语句 <code>&lt;%# note %&gt;</code></h5></li>
        <li><h5>该语句注释相关模板，注释不会被生成到go代码里边去。</h5></li>
        <li><h5>例: <code>&lt;# 这是一个注释 &gt;</code>.</h5></li>
        </ul>
</ul>
<h4> mvc</h4>
<h4> 认证框架</h4>
<h4> 文件上传</h4>
<h4> 测试</h4>
</div>
                                
                            <h3 id="Spring">Spring</h3>
                            <ul class="list-unstyled">
                                <ul>
                                    <li>Spring配置</li>
                                    <li>bean实例化</li>
                                    <li>属性注入</li>
                                    <li>注解操作</li>
                                    <li>AOP</li>
                                    <li>jdbcTemplate</li>
                                    <li>监听器</li>
                                    <li>SSH整合</li>
                                </ul>
                            </ul>
                            <blockquote>
                                <p> 开源轻量级框架</p>
                                <p>  核心：AOP、IOC</p>
                                <p> 一站式框架</p>
                                <p>  Spring5.0.3</p>
                            </blockquote>
                            <h4>Spring配置:</h4>
                            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- bean definitions here --&gt;
    &lt;context:component-scan base-package="扫描的包名"&gt;&lt;/context:component-scan&gt;
    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;
&lt;/beans&gt;
web.xml
&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;
&lt;listen&gt;
    &lt;listen-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listen-class&gt;
&lt;/listen&gt;</pre>
                            <h4> bean实例化:
                                <ul>
                                    <li><h5>无参构造√:</h5>  
                                        <pre>
&lt;bean id="名称" class="全路径"&gt;&lt;/bean&gt;   //不含特殊符号 name属性可以加特殊符号
//scope singletou 默认,单实例 prototype多实例
</pre>
                                    </li>
                                    <li>
                                        <h5>静态工厂:</h5>  
                                        <pre>
静态工厂类里
public static Bean getBean() {
    return new Bean();
}
&lt;bean id="名称" class="全路径" factory-method="getBean"&gt;&lt;/bean&gt;  
</pre>
                                    </li>
                                    <li>
                                        <h5>实例工厂：</h5>
                                        <pre>
实例工厂类里  
public Bean getBean() {
    return new Bean();
}
&lt;bean id="工厂类名" class="全路径"&gt;&lt;/bean&gt;
&lt;bean id="名称" factory-bean="工厂类名" factory-method="getBean"&gt;&lt;/bean&gt;  
</pre>
                                    </li>
                                </ul>
                                <h4>属性注入 :</h4>
                                <ul>
                                    <li><h5>有参构造注入</h5>
                                        <pre>
&lt;bean id="名称" class="全路径"&gt;
    &lt;constructor-arg name="属性名" value="值"&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;  
</pre>
                                    </li>
                                    <li><h5>set注入√</h5>  
                                        <pre>
&lt;bean id="名称" class="全路径"&gt;
    &lt;property name="属性名" value="值"&gt;&lt;/property&gt;
&lt;/bean&gt;  
</pre>
                                    </li>
                                    <li><h5>注入对象属性</h5>
                                        <pre>
service类里加入set方法
&lt;bean id="名称" class="DAO类全路径"&gt;&lt;/bean&gt;  
&lt;bean id="名称" class="service类全路径"&gt;
    &lt;property name="set的属性名" ref="名称"&gt;&lt;/proterty&gt;
</pre>
                                    </li>
                                    <li><h5>p名称空间注入</h5>  
                                        <pre>
xmlns:p="http://www.springframework.org/schema/p"
&lt;bean id="名称" class="DAO全路径" p:属性名="属性值"&gt;&lt;/p&gt;
</pre>
                                    </li>
                                    <li><h5>数组/Map/List注入</h5>  
                                        <pre>
&lt;bean id="名称" class="全路径"&gt;
    &lt;property name="属性名"&gt;
    &lt;list/map&gt;
        &lt;value&gt;...&lt;/value&gt;
        //&lt;entry key="" value=""&gt;&lt;/entry&gt;
    &lt;list/map&gt;
    &lt;/property&gt;  
&lt;/bean&gt;
</pre>
                                    </li>
                                </ul>
                                <h4>注解操作:</h4>
                                <ul>
                                    <li>注解创建对象
                                        <pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- bean definitions here --&gt;
    &lt;context:component-scan base-package=""&gt;&lt;/context:component-scan&gt;
&lt;/beans&gt;
@Component(value="名称")  
类 
@Controller 表述层  @Service 业务逻辑层  @Respository  数据访问层  
</pre>
                                    </li>
                                    <li>注解注入属性
                                        <pre>
@Autowired
private 类 对象;  
或
@Resource(name="要引用的对象的Component里的value值");  
</pre>
                                    </li>
                                </ul>
                                Bean用来创建对象 注解用来注入属性
                                <pre>
&lt;bean id="名称" class="被作为属性的对象的类的全路径"&gt;&lt;/bean&gt;  
@Resource(name="名称")
private 类 对象名;
</pre>
                                <h4>AOP:</h4>
                                <ul>
                                    <li>xml配置
                                        <pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- bean definitions here --&gt;
&lt;bean id="名称" class="增强的类"&gt;&lt;/bean&gt;  
&lt;bean id="名称" class="被增强的类"&gt;&lt;/bean&gt;  
&lt;aop:config&gt;
    &lt;aop:pointcut expression="execution(* 包.被增强方法(..))" id="名称"/&gt;
    &lt;aop:aspect ref="增强的类名称"&gt;
        &lt;aop:类型(before/after-returning/around) method="增强方法名"/ pointcut-ref="被增强方法(切入点)名称"&gt;  
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
&lt;/beans&gt;
</pre>
                                    </li>
                                    <li>注解
                                        <pre>
&lt;bean ...&gt;
&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;
@Aspect
public class 增强类{
    @类型(value="execution(* 被增强类.切入点())")
    public void 增强方法(){
        ...
    }
}
</pre>
                                    </li>
                                </ul>
                                //环绕 proceedingJoinPoint.proceed();  
                                <h4>jdbcTemplate</h4>
                                <ul>
                                    <li>增删改
                                        <pre>
DriverManagerDataSource dataSource = new DriverManagerDataSource();
dataSource.setDriverClassName("com.mysql.jdbc.Driver");
dataSource.setUrl("jdbc:mysql:///库");
dataSource.setUsername("");
dataSource.setPassword("");
JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSouce);
String sql = "xxx ? xxx"
int rows = jdbcTemplate.update(sql,"value");
</pre>
                                    </li>
                                    <li>查询
                                        <ul>
                                            <li>返回一个值
                                                <pre>
    int num = jdbcTemplate.queryForObject(sql,Integer.class);
  </pre>
                                            </li>
                                            <li>返回一个对象
                                                <pre>
    Entity Entity_name = jdbcTemplate.queryForObject(sql,new MyRowMapper(),"value");
    class MyRowMapper implements RowMapper&lt;Entity&gt;{
    重写mapRow{
        re.getString......;
        Entity Entity_name = new Entity();
        set........;
        return Entity;
        }
     }
   </pre>
                                            </li>
                                            <li>返回一个List
                                                <pre>
    List&lt;Entity&gt; list = jdbcTemplate.query(sql,new MyRowMapper());
  </pre>
                                            </li>
                                        </ul>
                                    </li>
                                    <li>连接池
                                        <pre>
&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;
    &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt;
    &lt;property name="jdbcUrl" value="jdbc:mysql:///库"&gt;&lt;/property&gt;
    &lt;property name="user" value=""&gt;&lt;/property&gt;
    &lt;property name="password" value=""&gt;&lt;/property&gt;
&lt;/bean&gt;
//Service注入DAO
//DAO注入jdbcTemplate
//jdbcTemplate注入连接池
&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;
&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;
&lt;/beans&gt;
</pre>
                                    </li>
                                    <li>事务
                                        <ul>
                                            <li>配置
                                                <pre>
    &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
    &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;tx:advice id="txadvice" transaction-manager="transactionManager"&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name="xxx*" propagation="REQUIRED"/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:adbice&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut expression:"execution(* 类.切入点(..))" id="pointcut"&gt;
        &lt;aop:advisor advice-ref="txadvice" pointcut-ref="pointcut"/&gt;
    &lt;/aop:config&gt;
  </pre>
                                            </li>
                                            <li>注解
                                                <pre>
    &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
    &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;
    @Transactional
    public class Service类{
    }
  </pre>
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                                <h4>监听器:</h4>
                                <pre>
&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:配置文件路径&lt;/param-value&gt;
&lt;/context-param&gt;  
&lt;listen&gt;
    &lt;listen-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listen-class&gt;
&lt;/listen&gt;
</pre>
                                <h4>SSH框架整合</h4>
                                <ul>
                                    <li>Struts2 整合 Spring
                                        <pre>
spring中
&lt;bean id="" class="类全路径" scope="prototype"&gt;
Struts2中
&lt;action name="" class="beanid"&gt;
</pre>
                                    </li>
                                    <li>Spring 整合 Hibernate
                                        <pre>
Hibernate内连接配置可以去掉
&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;
    &lt;property name="configLocations" value="classpath:hibernate.cfg.xml"&gt;&lt;/property&gt;
&lt;/bean&gt;
</pre>
                                    </li>
                                    <li>Hibernate Template
                                        <pre>
&lt;bean id="Dao" class="Dao类"&gt;
    &lt;property name="hibernateTemplate" ref="hibernateTemplate"&gt;
&lt;/bean&gt;
&lt;bean id="hibernateTemplate" class="org.springframework.orm.hibernate5.HibernateTemplate"&gt;
    &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id="transactionManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;tx:annotation-driven  transaction-manager="transactionManager"&gt;
@Transactional
Service类{
}
</pre>
                                        <pre>
get方法(根据id查询)
Entity Entity_name = hibernateTemplate.get(Entity.class,id);
find方法(条件查询)
List&lt;Entity&gt; list = (List&lt;Entity&gt;) hibernateTemplate.find(HQL,value);
分页查询
hibernateTemplate.findByCriteria(DetachedCriteria criteria,firstResult,maxResults)
</pre>
                                    </li>
                                    <li>分模块
                                        <pre>
&lt;import resource="classpath:xxx.xml"/&gt;
</pre>
                                    </li>
                                </ul>
                                </div>
                                <div>
                                        <h2 id="Hibernate">Hibernate 框架</h2>
                                        <h3>Hibernate</h3>
                                        <ul>
                                            <li>实体类</li>
                                            <li>配置</li>
                                            <li>实现</li>
                                            <li>CRUD</li>
                                            <li>事务</li>
                                            <li>绑定session</li>
                                            <li>查询</li>
                                            <li>一对多</li>
                                            <li>多对多</li>
                                            <li>查询(深入)</li>
                                            <blockquote>
                                                <p>数据访问层框架</p>
                                                <p>Hibernate 5.2.12</p>
                                            </blockquote>
                                            <h4>实体类:</h4>
                                            <pre>
          Public class 表名{
            private 类型 属性名;
            ....
            get函数;
            ....
            set函数;
            ....
          }
        </pre>
                                            <h4>映射配置:</h4>
                                            <pre>
          &lt;?xml version="1.0" encoding="UTF-8"?&gt;  
          &lt;!DOCTYPE hibernate-mapping PUBLIC
            "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
            "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;
        &lt;hibernate-mapping&gt;
            &lt;class name="实体类全路径" table="表名"&gt;  
                &lt;id name="主键属性名" column="主键字段名"&gt;  
                    &lt;generator class=""&gt;&lt;/generator&gt;  
                &lt;/id&gt;
                &lt;property name="属性名" column="字段名"&gt;&lt;/property&gt;  
            &lt;/class&gt;
        &lt;/hibernate-mapping&gt;
        &lt;xml-body&gt;
        &lt;/xml-body&gt;
    
        generator: increment / identity / sequence / native(√) / uuid(String) / assigned
        </pre>
                                            <h4> 核心配置:</h4>
                                            <pre>
          &lt;?xml version="1.0" encoding="UTF-8"?&gt;
          &lt;!DOCTYPE hibernate-configuration PUBLIC
            "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
            "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;
          &lt;hibernate-configuration&gt;
            &lt;session-factory&gt;
                &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;
                &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://localhost:3306/&lt;/property&gt;
                &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt;
                &lt;property name="hibernate.connection.password"&gt;&lt;/property&gt;
                &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt;
                &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt;
                &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt;
                &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;
                &lt;mapping resource="entity\userdata.hbm.xml"/&gt;
            &lt;/session-factory&gt;
          &lt;/hibernate-configuration&gt;
          &lt;xml-body&gt;
    
          &lt;/xml-body&gt;
        </pre>
                                            <h4>实现：</h4>
                                            <pre>
          Configuration cfg = new Configuration();
          cfg.configure();
          SessionFactory sessionFactory = cfg.buildSessionFactory();
          Session session = sessionFactory.openSession();
          Transaction tx = session.beginTransaction();
          //功能
          userdata userdata = new userdata();
          session.save(userdata);
          //
          tx.commit();
          session.close();
          sessionFactory.close();
        </pre>
                                            <h4>查找操作:</h4>
                                            <pre>
        //Configuration cfg = new Configuration();
        //cfg.configure();
        //SessionFactory sessionFactory = cfg.buildSessionFactory();
        SessionFactory sessionFactory = HibernateUtils.getSessionFactory();
        Session session = sessionFactory.openSession();
        Transaction tx = session.beginTransaction();
        //get语句
        userdata userdata = session.get(userdata.class,记录主键值);
        //输出 System.out.println.........
        tx.commit();
        session.close();
        //sessionFactory.close();
        </pre>
                                            <h4> 修改操作:</h4>
                                            <pre>
        userdata userdata = session.get(userdata.class,记录主键值);
        userdata.set属性名(记录值);
        session.update(userdata);
        </pre>
                                            <h4> 删除操作: </h4>
                                            <pre>
        userdata userdata = session.get(userdata.class,记录主键值);
        session.delete(userdata);
        </pre>
                                            <h4>事务:</h4>
                                            <pre>
        SessionFactory  sessionfactory = null;
        Session session = null;
        Transaction tx = null;
        try{
            sessionfactory = HibernateUtils.getSessionFactory();
            session = sessionfactory.openSession();
            tx = session.beginTransaction();
            //  
            tx.commit();
        }catch(Exception e){
            tx.rollback();
        }finally{
             session.close();
        }
        </pre>
                                            <h4>绑定session:</h4>
                                            <pre>
        &lt;property name="hibernate.current_session_context_class"&gt;thread&lt;/property&gt;
        public static Session getSessionobject() {
                return sessionFactory.getCurrentSession();
            }
        Session session = HibernateUtils.getSessionobject();
        </pre>
                                            <h4>查询</h4> 
                                            <ul>
                                                <li>Query:
                                                    <pre>
        Query query = session.createQuery(HQL(from userdata));
        List&lt;userdata&gt; list = query.list();
        遍历
        </pre>
                                                </li>
                                                <li>Criteria:  
                                                    <pre>
        Criteria criteria = session.createCriteria(userdata.class);
        List&lt;userdata&gt; list = criteria.list();
        遍历
        </pre>
                                                </li>
                                                <li>SQLQuery:
                                                    <pre>
        SQLQuery sqlQuery = session.createSQLQuery(SQL(select * from userdata));
        //List&lt;Object[]&gt; list = sqlQuery.list();
        //遍历(数组)
        sqlQuery.addEntity(userdata.class);
        List&lt;userdata&gt; list = sqlQuery.list();
        遍历
        </pre>
                                                </li>
                                            </ul>
                                            <h4>一对多:</h4>
                                            <ul>
                                                <li>映射:  
                                                    <pre>
        Entity1一对多Entity2:
        Entity1中
        private set&lt;Entity2&gt; Entity2_name = new HashSet&lt;Entity2&gt;();
        get()....set().....
        Entity2中
        private Entity1 Entity1_name;
        get()...set...
        Entity1.hbm.xml中  
        &lt;set name="Entity2_name"&gt;
        &lt;key column="外键名"&gt;&lt;/key&gt;
        &lt;one-to-many class="Entity2全路径"/&gt;
        &lt;/set&gt;
        Entity2.hbm.xml中
        &lt;many-to-one name="Entity1_name" class="Entity1全路径" column="外键名"&gt;&lt;/many-to-one&gt;
        </pre>
                                                </li>
                                                <li>级联保存:  
                                                    <pre>
        Entity1_name.getSetEntity2().add(Entity2_name1);
        Entity1_name.getSetEntity2().add(Entity2_name2);
        Entity2_name1.setEntity1(Entity1_name);
        Entity2_name2.setEntity1(Entity1_name);
        session.save(Entity1_name);
        session.save(Entity2_name1);
        session.save(Entity2_name2);  
        或者
        Entity1.hbm.xml中
        set标签内添加 cascade="save-update"
        Entity1_name.getSetEntity2().add(Entity2_name1);
        Entity1_name.getSetEntity2().add(Entity2_name2);
        session.save(Entity1_name);
        </pre>
                                                </li>
                                                <li>级联删除:  
                                                    <pre>
        cascade加入delete
        session.delete(Entity1_name);
        </pre>
                                                </li>
                                                <li>修改:  
                                                    <pre>
        Entity1.hbm.xml中
        set标签内添加 inverse="false"
        Entity1_name.getsetEntity2().add(Entity2_name);
        Entity2_name.setEntity1(Entity1_name);
        </pre>
                                                </li>
                                            </ul>
                                            <h4>多对多:</h4>
                                            <ul>
                                                <li>映射:  
                                                    <pre>
        Entity1中
        private set&lt;Entity2&gt; Entity2_name = new HashSet&lt;Entity2&gt;();
        get()....set().....
        Entity2中
        private set&lt;Entity1&gt; Entity1_name = new HashSet&lt;Entity1&gt;();
        get()....set().....
        Entity1.hbm.xml中  
        &lt;set name="Entity2_name" table="维护的表名"&gt;  
        &lt;key column="Entity1外键名"&gt;&lt;/key&gt;
        &lt;many-to-many class="Entity2全路径" column="Entity2外键名"/&gt;
        &lt;/set&gt;
        Entity2.hbm.xml中
        &lt;set name="Entity1_name" table="维护的表名"&gt;  
        &lt;key column="Entity2外键名"&gt;&lt;/key&gt;
        &lt;many-to-many class="Entity1全路径" column="Entity1外键名"/&gt;
        &lt;/set&gt;
        </pre>
                                                </li>
                                                <li>级联保存:  
                                                    <pre>
        若要用Entity1保存Entity2
        Entity1.hbm.xml中  
        set标签内添加 cascade="save-update"
        Entity1_name1.getSetEntity2().add(Entity2_name1);
        Entity1_name1.getSetEntity2().add(Entity2_name2);
        Entity1_name2.getSetEntity2().add(Entity2_name2);
        Entity1_name2.getSetEntity2().add(Entity2_name3);
        session.save(Entity1_name1);
        session.save(Entity1_name2);
        </pre>
                                                </li>
                                                <li>级联删除:  
                                                    <pre>
        //一般不用,也用不到
        cascade加入delete  
        session.delete(Entity1_name1);
        </pre>
                                                </li>
                                                <li>维护第三张表:  
                                                    <pre>
        Entity1和Entity2相关联
        Entity1_name.getsetEntity2().add(Entity2_name);  
        Entity1和Entity2取消关联  
        Entity1_name.getsetEntity2().remove(Entity2_name);  
        </pre>
                                                </li>
                                            </ul>
                                            <h4>查询:</h4>
                                            <ul>
                                                <li>对象导航查询:  
                                                    <pre>
        Set&lt;Entity2&gt; Entity2_name = Entity1_name.getSetEntity2();
        </pre>
                                                </li>
                                                <li>OID查询:  
                                                    <pre>
        Entity Entity_name = session.get(Entity.class,记录主键值);
        </pre>
                                                </li>
                                                <li>HQL查询:  
                                                    <pre>
        Query query = session.createQuery(HQL);
        query.setParameter(位置,值);
        List&lt;userdata&gt; list = query.list();
        遍历
        条件查询 from 实体类名 where 实体类属性 = ?
        条件查询 from 实体类名 where 实体类属性 like ?  
        排序查询 freom 实体类名 order by 实体类属性 asc/desc  
        分页查询 query.setFirstResult(第一条记录);query.setMaxResults(记录数);  
        投影查询 select 实体类属性 from  
        聚集函数 select 聚集函数 from...hving.. ...  Object obj = query.uniqueResult(); 遍历obj  
        连接查询 from Entity1 e inner join e.setEntity2 ... List list = query.list();
        迫切连接 from Entity1 e inner join fetch e.setEntity2 ... List list = query.list();
        </pre>
                                                </li>
                                                <li>QBC查询:  
                                                    <pre>
        Criteria criteria = session.createCriteria(Entity.class);
        List&lt;Entity&gt; list = criteria.list();
        遍历
        条件查询 criteria.add(Restrictions.方法(属性名,值));
        排序查询 criteria.addOrder(Order.方法(属性名));
        分页查询 criteria.setFirstResult(第一条记录);criteria.setMaxResults(记录数);
        统计查询 criteria.setProjection(Projection.rowCount());Object obj = criteria.uniqueResult();
        离线查询 
        DetachedCriteria detachedcriteria = DetachedCriteria.forClass(Entity.class);
        Criteria criteria = detachedcriteria.getExecutableCriteria(session);  
        批量抓取 set加入batch-size="10"标签
        </pre>
                                                </li>
                                                <li>本地SQL查询:  
                                                    <pre>
        ...
        </pre>
                                                </li>
                                            </ul>
                                            </div>
                                            <div>
                                                    <h2 id="Struts2">Struts2 框架</h2>
                                                    <ul>
                                                        <li>配置</li>
                                                        <li>创建action</li>
                                                        <li>方法访问</li>
                                                        <li>全局结果页面配置</li>
                                                        <li>获取表单</li>
                                                        <li>操作域对象</li>
                                                        <li>封装到实体类</li>
                                                        <li>值栈</li>
                                                        <li>拦截器</li>
                                                    </ul>
                                                    <blockquote>
                                                        <p>表述层框架</p>
                                                        <p>struts-2.5.14</p>
                                                    </blockquote>
                                                    <h4>配置 :</h4>
                                                    <pre>
                配置过滤器
                &lt;filter&gt;
                    &lt;filter-name&gt;struts2&lt;/filter-name&gt;
                    &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;
                &lt;/filter&gt;
                &lt;filter-mapping&gt;
                    &lt;filter-name&gt;struts2&lt;/filter-name&gt;
                    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
                &lt;/filter-mapping&gt;
                struts.xml  
                &lt;!DOCTYPE struts PUBLIC
                        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"
                        "http://struts.apache.org/dtds/struts-2.5.dtd"&gt;
                 &lt;struts&gt;
                         &lt;package name="用于区分的名称" extends="struts-default" namespace="/"&gt;&lt;!-- namespace+actionname 构成访问路径 --&gt;
                                 &lt;action name="访问名称" class="类全路径" method="默认为execute方法"&gt;
                                         &lt;result name="返回值" type="默认为转发(dispatcher)chain/redirect/redirectAction"&gt;/返回页面&lt;/result&gt;
                                 &lt;/action&gt;
                         &lt;/package&gt;
                 &lt;/struts&gt;
                 编码: &lt;constant name="struts.i18n.encoding" value="UTF-8"&gt;&lt;/constant&gt;
                 分模块 &lt;include file="全路径"&gt;&lt;/include&gt;
                </pre>
                                                    <h4>创建action:</h4>
                                                    <ul>
                                                        <li>1.
                                                            <pre>
                public class 名称 {
                public String execute() {
                        return "返回值";
                    }
                }
                </pre>
                                                        </li>
                                                        <li>2
                                                            <pre>
                import com.opensymphony.xwork2.Action;
                public class 名称 implements Action {  
                    @Override
                    public String execute() throws Exception {
                        // TODO Auto-generated method stub
                        return null;
                    }
                }
                </pre>
                                                        </li>
                                                        <li>3√
                                                            <pre>
                import com.opensymphony.xwork2.ActionSupport;
                public class 名称 extends ActionSupport {  
                    @Override
                    public String execute() throws Exception {
                        // TODO Auto-generated method stub
                        return "";
                    }
                }  
                </pre>
                                                        </li>
                                                    </ul>
                                                    <h4>方法访问:</h4>
                                                    <pre>
                &lt;package name="名称" extends="struts-default" namespace="/"&gt;
                     &lt;action name="index_*" class="全路径" method="{1}"&gt;
                             &lt;result name="返回值"&gt;/网页&lt;/result&gt;
                     &lt;/action&gt;
                 &lt;/package&gt;
                </pre>
                                                    <h4>全局结果页面配置:</h4> 
                                                    <pre>
                &lt;package&gt;
                &lt;global-results&gt;&lt;result name="...."&gt;/....&lt;/result&gt;&lt;/global-results&gt;
                </pre>
                                                    <h4>获取表单:</h4>  
                                                    <pre>
                //耦合低
                ActionContext context = ActionContext.getContext();  
                Map&lt;String,Object&gt; map = context.getParameters();  
                Set&lt;String&gt; keys = map.keySet();
                for(String key:keys)
                {
                    Object[] obj = (Object[])map.get(key);
                    ...
                }  
                </pre>
                                                    或 
                                                    <pre>
                //常用
                HttpServletRequest request = ServletActionContext.getRequest();  
                String xxx = request.getParameter("xxx");  
                </pre>
                                                    或 
                                                    <pre>
                implements ServletRequestAware
                private HttpServletRequest request;
                public void setServletRequest(HttpServletRequest request) {
                    this.request = request;
                }
                </pre>
                                                    <h4>操作域对象:</h4>  
                                                    <pre>
                HttpServletRequest request = ServletActionContext.getRequest();
                request.setAttribute("名","值");
                HttpSession session = request.getSession();
                session.setAttribute("名","值");
                ServletContext context = ServletActionContext.getServletContext();
                context.setAttribute("名","值");
                </pre>
                                                    <h4>封装到实体类:</h4>  
                                                    <pre>
                public class index_action extends ActionSupport {  
                    定义变量;
                    get()....set()....;
                    @Override  
                    public String execute() throws Exception {
                        // TODO Auto-generated method stub
                        return "";
                    }
                }  
                </pre>
                                                    或  √
                                                    <pre>
                public class index_action extends ActionSupport implements ModelDriven&lt;Entity&gt; {  
                    private Entity Entity_name = new Entity();
                    public Entity getModel(){
                        return Entity;
                    }
                    @Override  
                    public String execute() throws Exception {
                        // TODO Auto-generated method stub
                        return "";
                    }
                }  
                </pre>
                                                    或 
                                                    <pre>
                &lt;input name="Entity_name.name"&gt;
                private Entity Entity_name;
                get()...set()...
                </pre>
                                                    <h4>值栈:</h4>
                                                    <ul>
                                                        <li>ognl:
                                                            <pre>
                &lt;% taglib uri="/struts-tags" prefix="s"%&gt;  
                &lt;s:property value="OGNL"&gt;  
                </pre>
                                                        </li>
                                                        <li>获取值栈对象
                                                            <pre>
                ActionContext context = ActionContext.getContext();
                ValueStack stack = context.getValueStack();  
                </pre>
                                                        </li>
                                                        <li>值栈内放数据
                                                            <pre>
                //stack.set("key","value");  
                或 
                //stack.push("value");  取 &lt;s:property value="[...].top"&gt;
                或 
                private String name;
                get()....;
                name="value";  
                </pre>
                                                        </li>
                                                        <li>值栈放对象:
                                                            <pre>
                private Entity Entity_name = new Entity();
                public Entity getEntity(){
                    return Entity_name;
                    }
                Entity_name.set().....;  
                </pre>
                                                        </li>
                                                        <li>值栈放List:
                                                            <pre>
                private List&lt;Entity&gt; list = new ArrayList&lt;Entity&gt;();
                public List&lt;Entity&gt; getList(){
                    return list;
                }  
                </pre>
                                                        </li>
                                                        <li>值栈取数据:
                                                            <pre>
                &lt;s:property value="key"/&gt;  
                </pre>
                                                        </li>
                                                        <li>值栈取对象:
                                                            <pre>
                &lt;s:property value="对象.属性"/&gt;  
                </pre>
                                                        </li>
                                                        <li>值栈取List:
                                                            <pre>
                &lt;s:property value="List[...].属性"/&gt; 或 &lt;s:iterator value="list"&gt;&lt;s:property value="属性"/&gt;&lt;/s:iterator&gt;  
                或 &lt;s:iterator value="list" var="name"&gt;&lt;s:property value="#name.属性"/&gt;&lt;s:iterator&gt;
                </pre>
                                                        </li>
                                                    </ul>
                                                    <h4>拦截器:</h4>  
                                                    <pre>
                extends AbstractInterceptor
                //implements Interceptor
                void init()
                void destory()
                String intercept(ActionInvocation invocation)  
                或 
                extends MethodFilterInterceptor  
                重写doIntercept(ActionInvocation invocation)方法  
                配置拦截器:
                &lt;package内&gt;
                &lt;interceptors&gt;&lt;interceptor name="名称" class="全路径"&gt;&lt;/interceptor&gt;&lt;/interceptors&gt;  
                &lt;action内&gt;
                &lt;interceptor-ref name="名称"&gt;&lt;param name="excludeMethods"&gt;方法名&lt;/param&gt;&lt;/interceptor-ref&gt;  
                &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt;
                登录拦截器:  
                public class 名称 extends MethodFilterInterceptor{
                    @Override
                    protected String doIntercept(ActionInvocation arg0) throws Exception {
                        // TODO Auto-generated method stub
                        HttpServletRequest request = ServletActionContext.getRequest();
                        Object obj = request.getSession().getAttribute("session名称");  
                        if(obj != null){
                            return arg0.invoke();
                        }else{
                            return "登录页面标签";
                        }
                    }
                }
                </pre>
                                                </div>
                                                <div>
                                                        <h2 id="ELJSTL">EL</h2>
                                                        <pre>
                    ${ Expression }
                    ${ 变量1 运算符 变量2}
                    pageScope requestScope sessionScope applicationScope
                    ${ bean.property }
                    ${ collection[elementName] }
                    pageContext param paramValues cookie initParam
                                                </pre>
                                                        <h2> JSTL</h2>
                                                        <pre>
                    &lt;c:out value="变量名"&gt;&lt;/c:out&gt;
                    &lt;c:set value="值" scope="容器" var="元素名"&gt;&lt;/c:set&gt;
                    &lt;c:remove var="元素名" scope="容器"&gt;&lt;/c:remove&gt;
                    &lt;c:if test="${ 判断条件 }"&gt; ... &lt;/c:if&gt;
                    &lt;c:choose&gt;
                    &lt;c:when test="${ 条件1 }"&gt;...&lt;/c:when&gt;
                    &lt;c:when test="${ 条件2 }"&gt;...&lt;/c:when&gt;
                    &lt;c:otherwise&gt;...&lt;/c:otherwise&gt;
                    &lt;/c:choose&gt;
                    &lt;c:forEach var="元素名"&gt; items="集合名" begin="起始" end="结束" step="步长"&gt;....&lt;/c:forEach&gt;
                    &lt;c:forTokens items="字符串" delims="分隔符" var="子串名" begin="起始" end="结束" step="步长"&gt;...&lt;/c:forTokens&gt;  
                    ${ fn:length(String或集合) }
                    ${ fn:contains("源字符串","子字符串")
                    ${ fn:startsWith("源字符串","指定字符串") }  
                    ${ fn:endsWith("源字符串","指定字符串") }  
                    ${ fn:escapeXML(特殊字符) }
                    ${ fn:indexOf("源字符串","指定字符串") }
                    ${ fn:join(数组,"分隔符") }
                    ${ fn:replace("源字符串","被替换字符","替换字符") }
                    ${ fn:split("源字符串","分隔符") }
                    ${ fn:substring("源字符串",起始位置,结束位置) }
                    ${ fn:substringAfter("源字符串","子字符串") }
                    ${ fn:substringBefore("源字符串","子字符串") }
                    ${ fn:toLowerCase("源字符串") }
                    ${ fn:toUpperCase("源字符串") }
                    ${ fn:trim("源字符串") }
                                            </pre>
                                                    </div>
                                                    <div>
                                                            <h2 id="AJAX">AXAJ与Struts2</h2>
                                                            <ul>
                                                                <li>Jquery
                                                                    <pre>
                        $(function() {
                            $("#按钮id").click(function() {
                            //提交的参数，name是struts action中对应的接收变量
                                var params = {
                                   name : $("#表单名称").val()
                                };
                                $.ajax({
                                    type: "POST",
                                    url: "Action名称",
                                    data: params,
                                    dataType:"text",
                                    //ajax返回值设置为text（json格式也可用它返回，可打印出结果，也可设置成json）
                                    success: function(json){
                                        var obj = $.parseJSON(json);
                                        var state_value = obj.result;
                                        //result是和action中定义的result变量的get方法对应的
                                        方法......
                                        ....
                                    },
                                    error: function(json){
                                        方法...
                                        ...
                                        return false;
                                    }
                                });
                            });
                        });
                        </pre>
                                                                </li>
                                                                <li>struts.xml
                                                                    <pre>
                         &lt;package name="" extends="json-default"&gt;
                            &lt;action name="" class="" method=""&gt;
                                &lt;result name="success" type="json"&gt;&lt;/result&gt;
                            &lt;/action&gt;
                        &lt;/package&gt;
                        </pre>
                                                                </li>
                                                                <li>Action
                                                                    <pre>
                        package action;
                        import com.opensymphony.xwork2.ActionSupport;
                        public class AjaxAction extends ActionSupport{
                            private static final long serialVersionUID = 1L;
                            private String name;
                            public String getName() {
                                return name;
                            }
                            public void setName(String name) {
                                this.name = name;
                            }
                            private String result;
                            public String getResult() {
                                return result;
                            }
                            public void setResult(String result) {
                                this.result = result;
                            }
                            public String addType() {
                                result = f(typename);
                                ....
                                return SUCCESS;
                            }
                        }
                        </pre>
                                                                </li>
                                                            </ul>
                                                        </div>
                                                        <div>
                                                                <h2 id="BootStrap">栅格与响应式</h2>
                                                                <ul>
                                                                    <li>栅格
                                                                        <pre>
                            超小屏幕 手机 (&lt;768px) .col-xs-
                            小屏幕 平板 (≥768px) .col-sm-
                            中等屏幕 桌面显示器 (≥992px) .col-md-
                            大屏幕 大桌面显示器 (≥1200px) .col-lg-
                            &lt;div class="row"&gt;
                              &lt;div class="col-xx-n"&gt;12栅格&lt;/div&gt;
                            &lt;/div&gt;
                            </pre>
                                                                    </li>
                                                                    <li>响应式
                                                                        <pre>
                            hidden-xs 超小屏幕不可见
                            visible-xs-block 在超小屏幕上可见
                            hidden-sm 小屏幕不可见
                            visible-sm-block 在小屏幕上可见不可见
                            hidden-md 中等屏幕不可见
                            visible-md-block 在中等屏幕上可见
                            hidden-lg 大屏幕不可见
                            visible-lg-block 在大屏幕上可见
                            hidden-xs hidden-sm 超小屏幕和小屏幕不可见
                            visible-xs-block visible-sm-block 在超小屏幕和小屏幕上可见
                            hidden-md hidden-lg 中等屏幕和大屏幕不可见
                            visible-md-block visible-lg-block 在中等屏幕和大屏幕上可见
                            hidden-xs hidden-md 超小屏幕和中等屏幕不可见
                            visible-xs-block visible-md-block 在超小屏幕和中等屏幕上可见
                            hidden-sm hidden-lg 小屏幕和大屏幕不可见
                            visible-sm-block visible-lg-block 在小屏幕和大屏幕上可见
                            hidden-xs hidden-lg 超小屏幕和大屏幕不可见
                            visible-xs-block visible-lg-block 在超小屏幕和大屏幕上可见
                            hidden-sm hidden-md 小屏幕和中等屏幕不可见
                            visible-sm-block visible-md-block 在小屏幕和中等屏幕上可见
                            </pre>
                                                                    </li>
                                                                </ul>
                                                            </div>
                                                            <div class="panel-body">
										<h2>websocket与netty框架</h2>
										<ul>
											<li>websocket
												<ul>
													<li>前端页面
														<pre>
	&lt;%@ page language="java" pageEncoding="UTF-8" %&gt;
	&lt;!DOCTYPE html&gt;
	&lt;html&gt;
	&lt;head&gt;
	    &lt;title&gt;WebSocket&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
	    &lt;button onclick="send()"&gt;发送消息&lt;/button&gt;
	    &lt;button onclick="closeWebSocket()"&gt;关闭WebSocket连接&lt;/button&gt;
	&lt;/body&gt;

	&lt;script type="text/javascript"&gt;
	    var websocket = null;
	    //判断当前浏览器是否支持WebSocket
	    if ('WebSocket' in window) {
	       websocket = new WebSocket("ws://112.74.97.185/websocket"); // 此处为服务器地址!!!不能是localhost!!!
	    }
	    else {
	        alert('当前浏览器不支持websocket')
	    }
	    //连接发生错误的回调方法
	    websocket.onerror = function () {
	        setMessageInnerHTML("WebSocket连接发生错误");
	    };
	    //连接成功建立的回调方法
	    websocket.onopen = function () {
	        //..
	    }

	    //接收到消息的回调方法
	    websocket.onmessage = function (event) {
	        //..
	    }
	    //连接关闭的回调方法
	    websocket.onclose = function () {
	        //..
	    }
	    //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。
	    window.onbeforeunload = function () {
	        closeWebSocket();
	    }
	    //关闭WebSocket连接
	    function closeWebSocket() {
	        websocket.close();
	    }
	    //发送消息
	    function send() {
	        var message = //..
	        websocket.send(message);
	    }
	&lt;/script&gt;
	&lt;/html&gt;
								  </pre>
													</li>
													<li>JAVA类
														<pre>
	package websocket;
	import java.io.IOException;
	import java.util.concurrent.CopyOnWriteArraySet;
	import javax.websocket.*;
	import javax.websocket.server.ServerEndpoint;
	// @ServerEndpoint 注解是一个类层次的注解
	@ServerEndpoint("/websocket")
	public class Websocket {
	  //静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。
	  private static int onlineCount = 0;
	  //concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。若要实现服务端与单一客户端通信的话，可以使用Map来存放，其中Key可以为用户标识
	  private static CopyOnWriteArraySet&lt;Websocket&gt; webSocketSet = new CopyOnWriteArraySet&lt;Websocket&gt;();
	  //与某个客户端的连接会话，需要通过它来给客户端发送数据
	  private Session session;
	  /**
	   * 连接建立成功调用的方法
	   * @param session  可选的参数。session为与某个客户端的连接会话，需要通过它来给客户端发送数据
	   */
	  @OnOpen
	  public void onOpen(Session session){
	      this.session = session;
	      webSocketSet.add(this);     //加入set中
	  }
	  //连接关闭调用的方法
	  @OnClose
	  public void onClose(){
	      webSocketSet.remove(this);  //从set中删除
	  }
	  /**
	   * 收到客户端消息后调用的方法
	   * @param message 客户端发送过来的消息
	   * @param session 可选的参数
	   */
	  @OnMessage
	  public void onMessage(String message, Session session) {
	      //群发消息
	      for(Websocket item: webSocketSet){
	          try {
	              item.sendMessage(message);
	          } catch (IOException e) {
	              e.printStackTrace();
	              continue;
	          }
	      }
	  }
	  //发生错误时调用
	  @OnError
	  public void onError(Session session, Throwable error){
	      System.out.println("发生错误");
	      error.printStackTrace();
	  }
	  public void sendMessage(String message) throws IOException{
	      this.session.getBasicRemote().sendText(message);
	  }
								    </pre></li>
													</li>
										</ul>
										<li>websocket使用http域对象
											<ul>
												<li>Configurator类中
													<pre>
	public class GetHttpSessionConfigurator extends Configurator {
	    @Override
	    public void modifyHandshake(ServerEndpointConfig sec,
	            HandshakeRequest request, HandshakeResponse response) {
	        // TODO Auto-generated method stub
	        HttpSession httpSession=(HttpSession) request.getHttpSession();
	        sec.getUserProperties().put(HttpSession.class.getName(),httpSession);
	    }
	}
								  </pre></li>
												<li>websocket类中
													<pre>
	@ServerEndpoint(value="/...",configurator=GetHttpSessionConfigurator.class)
	public void ...(...,EndpointConfig config)
	HttpSession httpSession= (HttpSession)config.getUserProperties().get(HttpSession.class.getName());
								  </pre></li>
											</ul>
										</li>
										</ul>
                                </div>
                <div class="panel-body">
										<h2>websocket与netty框架</h2>
										<ul>
											<li>websocket
												<ul>
													<li>前端页面
														<pre>
	&lt;%@ page language="java" pageEncoding="UTF-8" %&gt;
	&lt;!DOCTYPE html&gt;
	&lt;html&gt;
	&lt;head&gt;
	    &lt;title&gt;WebSocket&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
	    &lt;button onclick="send()"&gt;发送消息&lt;/button&gt;
	    &lt;button onclick="closeWebSocket()"&gt;关闭WebSocket连接&lt;/button&gt;
	&lt;/body&gt;

	&lt;script type="text/javascript"&gt;
	    var websocket = null;
	    //判断当前浏览器是否支持WebSocket
	    if ('WebSocket' in window) {
	       websocket = new WebSocket("ws://112.74.97.185/websocket"); // 此处为服务器地址!!!不能是localhost!!!
	    }
	    else {
	        alert('当前浏览器不支持websocket')
	    }
	    //连接发生错误的回调方法
	    websocket.onerror = function () {
	        setMessageInnerHTML("WebSocket连接发生错误");
	    };
	    //连接成功建立的回调方法
	    websocket.onopen = function () {
	        //..
	    }

	    //接收到消息的回调方法
	    websocket.onmessage = function (event) {
	        //..
	    }
	    //连接关闭的回调方法
	    websocket.onclose = function () {
	        //..
	    }
	    //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。
	    window.onbeforeunload = function () {
	        closeWebSocket();
	    }
	    //关闭WebSocket连接
	    function closeWebSocket() {
	        websocket.close();
	    }
	    //发送消息
	    function send() {
	        var message = //..
	        websocket.send(message);
	    }
	&lt;/script&gt;
	&lt;/html&gt;
								  </pre>
													</li>
													<li>JAVA类
														<pre>
	package websocket;
	import java.io.IOException;
	import java.util.concurrent.CopyOnWriteArraySet;
	import javax.websocket.*;
	import javax.websocket.server.ServerEndpoint;
	// @ServerEndpoint 注解是一个类层次的注解
	@ServerEndpoint("/websocket")
	public class Websocket {
	  //静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。
	  private static int onlineCount = 0;
	  //concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。若要实现服务端与单一客户端通信的话，可以使用Map来存放，其中Key可以为用户标识
	  private static CopyOnWriteArraySet&lt;Websocket&gt; webSocketSet = new CopyOnWriteArraySet&lt;Websocket&gt;();
	  //与某个客户端的连接会话，需要通过它来给客户端发送数据
	  private Session session;
	  /**
	   * 连接建立成功调用的方法
	   * @param session  可选的参数。session为与某个客户端的连接会话，需要通过它来给客户端发送数据
	   */
	  @OnOpen
	  public void onOpen(Session session){
	      this.session = session;
	      webSocketSet.add(this);     //加入set中
	  }
	  //连接关闭调用的方法
	  @OnClose
	  public void onClose(){
	      webSocketSet.remove(this);  //从set中删除
	  }
	  /**
	   * 收到客户端消息后调用的方法
	   * @param message 客户端发送过来的消息
	   * @param session 可选的参数
	   */
	  @OnMessage
	  public void onMessage(String message, Session session) {
	      //群发消息
	      for(Websocket item: webSocketSet){
	          try {
	              item.sendMessage(message);
	          } catch (IOException e) {
	              e.printStackTrace();
	              continue;
	          }
	      }
	  }
	  //发生错误时调用
	  @OnError
	  public void onError(Session session, Throwable error){
	      System.out.println("发生错误");
	      error.printStackTrace();
	  }
	  public void sendMessage(String message) throws IOException{
	      this.session.getBasicRemote().sendText(message);
	  }
								    </pre></li>
													</li>
										</ul>
										<li>websocket使用http域对象
											<ul>
												<li>Configurator类中
													<pre>
	public class GetHttpSessionConfigurator extends Configurator {
	    @Override
	    public void modifyHandshake(ServerEndpointConfig sec,
	            HandshakeRequest request, HandshakeResponse response) {
	        // TODO Auto-generated method stub
	        HttpSession httpSession=(HttpSession) request.getHttpSession();
	        sec.getUserProperties().put(HttpSession.class.getName(),httpSession);
	    }
	}
								  </pre></li>
												<li>websocket类中
													<pre>
	@ServerEndpoint(value="/...",configurator=GetHttpSessionConfigurator.class)
	public void ...(...,EndpointConfig config)
	HttpSession httpSession= (HttpSession)config.getUserProperties().get(HttpSession.class.getName());
								  </pre></li>
											</ul>
										</li>
										</ul>
                                </div>
                                <div>
										<h2 id="websocket">websocket与netty框架</h2>
										<ul>
											<li>websocket
												<ul>
													<li>前端页面
														<pre>
	&lt;%@ page language="java" pageEncoding="UTF-8" %&gt;
	&lt;!DOCTYPE html&gt;
	&lt;html&gt;
	&lt;head&gt;
	    &lt;title&gt;WebSocket&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
	    &lt;button onclick="send()"&gt;发送消息&lt;/button&gt;
	    &lt;button onclick="closeWebSocket()"&gt;关闭WebSocket连接&lt;/button&gt;
	&lt;/body&gt;

	&lt;script type="text/javascript"&gt;
	    var websocket = null;
	    //判断当前浏览器是否支持WebSocket
	    if ('WebSocket' in window) {
	       websocket = new WebSocket("ws://112.74.97.185/websocket"); // 此处为服务器地址!!!不能是localhost!!!
	    }
	    else {
	        alert('当前浏览器不支持websocket')
	    }
	    //连接发生错误的回调方法
	    websocket.onerror = function () {
	        setMessageInnerHTML("WebSocket连接发生错误");
	    };
	    //连接成功建立的回调方法
	    websocket.onopen = function () {
	        //..
	    }

	    //接收到消息的回调方法
	    websocket.onmessage = function (event) {
	        //..
	    }
	    //连接关闭的回调方法
	    websocket.onclose = function () {
	        //..
	    }
	    //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。
	    window.onbeforeunload = function () {
	        closeWebSocket();
	    }
	    //关闭WebSocket连接
	    function closeWebSocket() {
	        websocket.close();
	    }
	    //发送消息
	    function send() {
	        var message = //..
	        websocket.send(message);
	    }
	&lt;/script&gt;
	&lt;/html&gt;
								  </pre>
													</li>
													<li>JAVA类
														<pre>
	package websocket;
	import java.io.IOException;
	import java.util.concurrent.CopyOnWriteArraySet;
	import javax.websocket.*;
	import javax.websocket.server.ServerEndpoint;
	// @ServerEndpoint 注解是一个类层次的注解
	@ServerEndpoint("/websocket")
	public class Websocket {
	  //静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。
	  private static int onlineCount = 0;
	  //concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。若要实现服务端与单一客户端通信的话，可以使用Map来存放，其中Key可以为用户标识
	  private static CopyOnWriteArraySet&lt;Websocket&gt; webSocketSet = new CopyOnWriteArraySet&lt;Websocket&gt;();
	  //与某个客户端的连接会话，需要通过它来给客户端发送数据
	  private Session session;
	  /**
	   * 连接建立成功调用的方法
	   * @param session  可选的参数。session为与某个客户端的连接会话，需要通过它来给客户端发送数据
	   */
	  @OnOpen
	  public void onOpen(Session session){
	      this.session = session;
	      webSocketSet.add(this);     //加入set中
	  }
	  //连接关闭调用的方法
	  @OnClose
	  public void onClose(){
	      webSocketSet.remove(this);  //从set中删除
	  }
	  /**
	   * 收到客户端消息后调用的方法
	   * @param message 客户端发送过来的消息
	   * @param session 可选的参数
	   */
	  @OnMessage
	  public void onMessage(String message, Session session) {
	      //群发消息
	      for(Websocket item: webSocketSet){
	          try {
	              item.sendMessage(message);
	          } catch (IOException e) {
	              e.printStackTrace();
	              continue;
	          }
	      }
	  }
	  //发生错误时调用
	  @OnError
	  public void onError(Session session, Throwable error){
	      System.out.println("发生错误");
	      error.printStackTrace();
	  }
	  public void sendMessage(String message) throws IOException{
	      this.session.getBasicRemote().sendText(message);
	  }
								    </pre></li>
													</li>
										</ul>
										<li>websocket使用http域对象
											<ul>
												<li>Configurator类中
													<pre>
	public class GetHttpSessionConfigurator extends Configurator {
	    @Override
	    public void modifyHandshake(ServerEndpointConfig sec,
	            HandshakeRequest request, HandshakeResponse response) {
	        // TODO Auto-generated method stub
	        HttpSession httpSession=(HttpSession) request.getHttpSession();
	        sec.getUserProperties().put(HttpSession.class.getName(),httpSession);
	    }
	}
								  </pre></li>
												<li>websocket类中
													<pre>
	@ServerEndpoint(value="/...",configurator=GetHttpSessionConfigurator.class)
	public void ...(...,EndpointConfig config)
	HttpSession httpSession= (HttpSession)config.getUserProperties().get(HttpSession.class.getName());
								  </pre></li>
											</ul>
										</li>
										</ul>
								</div>
            </div>
        <div class="col-md-2 col-lg-2 col-sm-1 col-xs-1"></div>
    </div>
    </body>
    </html>