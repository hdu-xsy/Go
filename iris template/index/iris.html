<div>
    <h3 id="go">GoLang与IRIS框架</h3>
    <div>
        <h3>Go IRIS框架学习笔记</h3>

        <blockquote>
            <p>当前网上关于Golang的IRIS框架的教程极极极极少，有参考价值的也就官方文档，</p>
            <p>可惜官网文档<strong>除 了 代 码 什 么 都 没 有</strong>，而且 还 <strong>没 有 中 文 版</strong>，竟 然 还 是 <strong>按 照 首 字 母 排 得 序</strong>，</p>
            <p>但是比起热门的GIN、BEEGO、马卡龙框架，IRIS还是有自己的特点的，于是在此整理方便学习和以后使用（以官方文档为主）  []内内容为备注(类型) [...]为方法</p>
        </blockquote>
        <h4>安装iris和导入iris</h4>
        <pre>
命令行:go get github.com/kataras/iris
</pre>
        <pre>
import (
    "github.com/kataras/iris"
)
</pre>
        <h4> 生成网页与注册路由的一般方法</h4>
        <ul>
            <li><h5>main函数中</h5></li>
            <pre>
app.RegisterView(iris.HTML("/html[directory]",".html[extension]").Reload(true))
app.StaticWeb("/js[request path]", "./js[system path]") // serve our custom javascript code
app.Get("/",index[funcName])  //路由
app.Run(iris.Addr(":80"))  //端口
</pre>
            <li><h5>路由函数中</h5></li>
            <pre>
func funcName(ctx iris.Context){
    if err := ctx.View("index.html");err!=nil {
            //错误处理[...]
    }
}
</pre>
            <li><h5>错误页面</h5></li>
            <pre>
app.OnErrorCode(iris.StatusNotFound, func(ctx iris.Context){
        ctx.View("404.html")
})
</pre>
        </ul>
        <h4> 读取POST请求和ORM基本操作</h4>
        <pre>
type 表名 struct {
    Id       int64`pk`
    字段名   string`unique`
    Password string`notnull`
}
// 生成的表会自动转化格式 如 AdminUser → admin_user
// 下面例子假定表名为admin_user
func Funcname(ctx iris.Context) {
    user := AdminUser{}
    //  读取请求
    err := ctx.ReadForm(&user)
    if err !=nil {
        //[..]
    }
    //  ORM
    //  mysql
    orm,err := xorm.NewEngine("mysql", "用户名:密码@/库名?charset=utf8")
    //  不同数据库操作不同 具体参考文档
    if err != nil {
        app.Logger().Fatalf("orm failed to initialized: %v", err)
    }
    iris.RegisterOnInterrupt(func(){
        orm.Close()
    })
    err = orm.Sync2(new(AdminUser))
    if err != nil {
        app.Logger().Fatalf("orm failed to initialized User table: %v", err)
    }
    adminuser := AdminUser{Account: user.Account}
    //查找操作
    if ok, _ := orm.Get(&adminuser); ok { //orm.Id(xxx).Get(&) 或 orm.Where("属性=?",value).Get(&)
    } else {
    }
    //插入操作
    adminuser.Account = "AAAAAAA"
    orm.Insert(adminuser)
    //修改操作
    orm.Id(xx).Update(adminuser)
    //删除操作
    orm.delete(adminuser)
    //查找全部
    var users []AdminUser
    orm.Find(&users)
    //详细操作日后再来学习
    //官方文档http://www.xorm.io/docs/
}
</pre>

        <h4>带参数的路径</h4>
        <pre>
app.Get("/{xxx}/{namedRoute}", func(ctx iris.Context) {
        xxx := ctx.Params().Get("xxx")
        routeName := ctx.Params().Get("namedRoute")
        //[...]
})
</pre>
        <h4> Ajax</h4>
        <ul>
            <li><h5>前端页面</h5></li>
            <pre>
&lt;script src="https://code.jquery.com/jquery-3.1.1.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
    $(function() {
        $("#按钮Id").click(function() {
            //提交的参数
            var params = {
                Account : $("#input的Id").val(),
                Password : $("#input的Id").val()
            };
            $.post("/路由",params,function (参数) {
                要执行的func(参数);
        });
    });
&lt;/script&gt;
</pre>
            <li><h5>Go</h5></li>
            <pre>
//接收post
user := AdminUser{}
err := ctx.ReadForm(&user)
if err !=nil {
    ctx.StatusCode(iris.StatusInternalServerError)
    ctx.WriteString(err.Error())
    ctx.Redirect("/404")
}
//要执行的操作func(user)
ctx.WriteString(返回值)
return
</pre>
        </ul>
        <h4> session</h4>
        <pre>
var (
    cookieNameForSessionID = "mycookiesessionnameid"
    sess                   = sessions.New(sessions.Config{Cookie: cookieNameForSessionID})
)
session := sess.Start(ctx)  //ctx iris.Context
session.Set（"key", value)
session.Get("key")  //若使用Get方法需要强转 指定：GetString GetInt GetBoolean GetAll GetFloat ...
session.Delete("key")   //删除
session.Clear()     //清空
session.Destroy()   //销毁
</pre>
        <h4> WebSokect</h4>
        <ul>
            <li><h5>iris的websocket</h5></li>
            <ul>
                <li><h5>html</h5></li>
                <pre>
    &lt;form name = "form1" method="post"&gt;
        输入聊天信息:&lt;input id="msg" name="msg" type="text" size="40" class="form-control"&gt;
    &lt;/form&gt;
    &lt;button name="websocket" id="websocket" class="btn btn-default" onclick="send()"&gt;发送&lt;/button&gt;
    &lt;script src="/iris-ws.js"&gt;&lt;/script&gt;
    &lt;div id="message" name="message"&gt;&lt;/div&gt;

    </pre>
                <li><h5>js</h5></li>
                <pre>
    var scheme = document.location.protocol == "https:" ? "wss" : "ws";
    var port = document.location.port ? (":" + document.location.port) : "";
    // see app.Get("/echo", ws.Handler()) on main.go
    var wsURL = scheme + "://" + document.location.hostname + port+"/echo";
    var input = document.getElementById("msg");
    var output = document.getElementById("message");
    // Ws comes from the auto-served '/iris-ws.js'
    var socket = new Ws(wsURL)
    socket.OnConnect(function () {
        //连接服务器[...]
    });
    socket.OnDisconnect(function () {
        //无法连接服务器[...]
    });
    // read events from the server
    socket.On("消息名称", function (msg) {
        //读取事件[...]
        addMessage(msg+"&lt;br/&gt;");
    });
    function send() {
        addMessage("Me: " + input.value); // write ourselves
        socket.Emit("消息名称", "消息内容");// send chat event data to the websocket server
        input.value = ""; // clear the input
    }
    function addMessage(msg) {
        output.innerHTML += msg + "&lt;br&gt;";
    }
    </pre>
                <li><h5>Go</h5></li>
                <pre>
    package main

    import (
        "github.com/kataras/iris"
        "github.com/kataras/iris/websocket"
        "github.com/go-xorm/xorm"
    )

    func setupWebsocket(app *iris.Application) {
        // create our echo websocket server
        ws := websocket.New(websocket.Config{
            ReadBufferSize:  1024,
            WriteBufferSize: 1024,
        })
        ws.OnConnection(handleConnection)
        // register the server on an endpoint.
        app.Get("/echo", ws.Handler())
        // see html script tags, this path is used.
        app.Any("/iris-ws.js", func(ctx iris.Context) {
            ctx.Write(websocket.ClientSource)
        })
    }

    func handleConnection(c websocket.Connection) {
        c.On("chat", func(msg string) {
            // fmt.Printf("%s sent: %s\n", c.Context().RemoteAddr(), msg)
            // Write message back to the client message owner with: c.Emit("消息名称", msg)
            // 返回所有人 websocket.All
            // Write message to all except this client with:
            c.To(websocket.Broadcast).Emit("消息名称", msg)
        })
        c.OnDisconnect(func() {
            //断开连接操作[...]
        })
    }
    func main() {
        setupWebsocket(app)
    }
    </pre>
            </ul>
            <li><h5>官方的websocket</h5></li>
            <li><h5>第三方websocket</h5></li>
        </ul>
        <h4> 模板</h4>
        <ul>
            <li><h5>上下文视图数据</h5></li>
            <pre>
app.Get("/路由", func(ctx iris.Context) {
        ctx.ViewData("Key", "Value")
        if err := ctx.View("index.html"); err != nil {
            //[...]
        }
})
//HTML中使用｛｛.Key｝｝获取
</pre>
            <li><h5>嵌入模板</h5></li>
            <pre>
//花括号为半角 因为用半角会自动翻译 所以这里用全角
//layout页面中加入｛｛ yield ｝｝使用模板
//HTML中使用｛｛funcName 参数｝｝使用函数 如下例中可使用 ｛｛ greet "string" ｝｝
//｛｛ render "路径" ｝｝ 把别的html文件的内容拿过来
func main() {
    app := iris.New()
    //全局模板 所有页面适用
    tmpl := iris.HTML("./templates[html文件夹路径]", ".html")
    tmpl.Layout("layouts/layout.html[layout文件路径]")
    tmpl.AddFunc("greet", func(s string) string {
        //[..]
    })
    tmpl.Binary(Asset, AssetNames) // &lt;-- ####IMPORTANT
    app.RegisterView(tmpl)
    app.Get("/", func(ctx iris.Context) {
        if err := ctx.View("page1.html"); err != nil {
            ctx.StatusCode(iris.StatusInternalServerError)
            ctx.Writef(err.Error())
        }
    })

    // 不使用全局模板
    app.Get("/nolayout", func(ctx iris.Context) {
        ctx.ViewLayout(iris.NoLayout)
        if err := ctx.View("page1.html"); err != nil {
            ctx.StatusCode(iris.StatusInternalServerError)
            ctx.Writef(err.Error())
        }
    })

    // 局部模板 不受全局模板影响
    my := app.Party("/my").Layout("layouts/mylayout.html") {
        my.Get("/", func(ctx iris.Context) {
            ctx.View("page1.html")
        })
        my.Get("/other", func(ctx iris.Context) {
            ctx.View("page2.html")
        })
    }
    app.Run(iris.Addr(":8080"))
}
</pre>
            <li><h5>hero</h5></li>
            <ul>
                <li><h5>官方文档 https://github.com/shiyanhui/hero/blob/master/README_CN.md</h5></li>
                <li><h5>iris中的实现</h5></li>
                <p>1. HTML中编写模板（语法见下）</p>
                <p>2. 命令行中进入%GOPATH%/bin 执行hero -source="模板所在文件夹"</p>
                <p>3. main函数中</p>
                <pre>
        //对于&lt;%: func FuncName(变量名 []string, buffer *bytes.Buffer) %&gt;
        app.Get("/路由", func(ctx iris.Context) {
            var 变量名 = []string{
                //变量值
                //..
            }
            // Had better use buffer sync.Pool.
            // Hero exports GetBuffer and PutBuffer for this.
            //
            // buffer := hero.GetBuffer()
            // defer hero.PutBuffer(buffer)
            buffer := new(bytes.Buffer)
            template.FuncName(变量名, buffer)
            if _, err := ctx.Write(buffer.Bytes()); err != nil {
                log.Printf("ERR: %s\n", err)
            }
        })

        </pre>
                <pre>
        //对于&lt;%: func FuncName(变量名 []string, w io.Writer) (int, error)%&gt;
        app.Get("/路由", func(ctx iris.Context) {
            var 变量名 = []string{
                //
            }
            // using an io.Writer for automatic buffer management (i.e. hero built-in buffer pool),
            // iris context implements the io.Writer by its ResponseWriter
            // which is an enhanced version of the standard http.ResponseWriter
            // but still 100% compatible.
            template.UserListToWriter(FuncName, ctx)
        })
    </pre>
                <li><h5>以下内容转自官方文档</h5></li>
                <li><h5>Hero总共有九种语句，他们分别是：</h5></li>
                <li><h5>函数定义语句 <code>&lt;%: func define %&gt;</code></h5></li>
                <ul>
                    <li><h5>该语句定义了该模板所对应的函数，如果一个模板中没有函数定义语句，那么最终结果不会生成对应的函数。</h5></li>
                    <li><h5>该函数最后一个参数必须为<code>*bytes.Buffer</code>或者<code>io.Writer</code>, hero会自动识别该参数的名字，并把把结果写到该参数里。</h5></li>
                    <li><h5>例:</h5></li>
                    <ul>
                        <li><h5><code>&lt;%: func UserList(userList []string, buffer *bytes.Buffer) %&gt;</code></h5></li>
                        <li><h5><code>&lt;%: func UserList(userList []string, w io.Writer) %&gt;</code></h5></li>
                        <li><h5><code>&lt;%: func UserList(userList []string, w io.Writer) (int, error) %&gt;</code></h5></li>
                    </ul>
                </ul>
                <li><h5>模板继承语句 <code>&lt;%~ "parent template" %&gt;</code></h5></li>
                <li><h5>该语句声明要继承的模板。</h5></li>
                <li><h5>例: <code>&lt;%~ "index.html" &gt;</code></h5></li>

                <li><h5>模板include语句 <code>&lt;%+ "sub template" %&gt;</code></h5></li>
                <li><h5>该语句把要include的模板加载进该模板，工作原理和<code>C++</code>中的<code>#include</code>有点类似。</h5></li>
                <li><h5>例: <code>&lt;%+ "user.html" &gt;</code></h5></li>

                <li><h5>包导入语句 <code>&lt;%! go code %&gt;</code></h5></li>
                <li><h5>该语句用来声明所有在函数外的代码，包括依赖包导入、全局变量、const等。</h5></li>

                <li><h5>该语句不会被子模板所继承</h5></li>

                <li><h5>例:</h5></li>

                <pre>go
        &lt;%!
            import (
                    "fmt"
                "strings"
            )

            var a int

            const b = "hello, world"

            func Add(a, b int) int {
                return a + b
            }

            type S struct {
                Name string
            }

            func (s S) String() string {
                return s.Name
            }
        %&gt;
        </pre>

                <li><h5>块语句 <code>&lt;%@ blockName { %&gt; &lt;% } %&gt;</code></h5></li>

                <li><h5>块语句是用来在子模板中重写父模中的同名块，进而实现模板的继承。</h5></li>

                <li><h5>例:</h5></li>

                <pre>html
        &lt;!DOCTYPE html&gt;
        &lt;html&gt;
            &lt;head&gt;
                &lt;meta charset="utf-8"&gt;
            &lt;/head&gt;

            &lt;body&gt;
                &lt;%@ body { %&gt;
                &lt;% } %&gt;
            &lt;/body&gt;
        &lt;/html&gt;
        </pre>

                <li><h5>Go代码语句 <code>&lt;% go code %&gt;</code></h5></li>

                <li><h5>该语句定义了函数内部的代码部分。</h5></li>

                <li><h5>例:</h5></li>

                <pre>go
        &lt;% for _, user := userList { %&gt;
            &lt;% if user != "Alice" { %&gt;
                &lt;%= user %&gt;
            &lt;% } %&gt;
        &lt;% } %&gt;

        &lt;%
            a, b := 1, 2
            c := Add(a, b)
        %&gt;
        </pre>

                <li><h5>原生值语句 <code>&lt;%==[t] variable %&gt;</code></h5></li>

                <li><h5>该语句把变量转换为string。</h5></li>

                <li><h5><code>t</code>是变量的类型，hero会自动根据<code>t</code>来选择转换函数。<code>t</code>的待选值有:</h5></li>
                <li><h5><code>b</code>: bool</h5></li>
                <li><h5><code>i</code>: int, int8, int16, int32, int64</h5></li>
                <li><h5><code>u</code>: byte, uint, uint8, uint16, uint32, uint64</h5></li>
                <li><h5><code>f</code>: float32, float64</h5></li>
                <li><h5><code>s</code>: string</h5></li>
                <li><h5><code>bs</code>: []byte</h5></li>
                <li><h5><code>v</code>: interface</h5></li>

                注意：
                <li><h5>如果<code>t</code>没有设置，那么<code>t</code>默认为<code>s</code>.</h5></li>
                <li><h5>最好不要使用<code>v</code>，因为其对应的转换函数为<code>fmt.Sprintf("%v", variable)</code>，该函数很慢。</h5></li>

                <li><h5>例:</h5></li>

                <pre>go
        &lt;%== "hello" %&gt;
        &lt;%==i 34  %&gt;
        &lt;%==u Add(a, b) %&gt;
        &lt;%==s user.Name %&gt;
        </pre>

                <li><h5>转义值语句 <code>&lt;%= statement %&gt;</code></h5></li>

                <li><h5>该语句把变量转换为string后，又通过<code>html.EscapesString</code>记性转义。</h5></li>
                <li><h5><code>t</code>跟上面原生值语句中的<code>t</code>一样。</h5></li>
                <li><h5>例:</h5></li>

                <pre>go
        &lt;%= a %&gt;
        &lt;%= a + b %&gt;
        &lt;%= Add(a, b) %&gt;
        &lt;%= user.Name %&gt;
        </pre>
                <li><h5>注释语句 <code>&lt;%# note %&gt;</code></h5></li>
                <li><h5>该语句注释相关模板，注释不会被生成到go代码里边去。</h5></li>
                <li><h5>例: <code>&lt;# 这是一个注释 &gt;</code>.</h5></li>
            </ul>
        </ul>
        <h4> mvc</h4>
        <h4> 认证框架</h4>
        <h4> 文件上传</h4>
        <h4> 测试</h4>
    </div>
</div>
<div><%+ "spring.html" %></div>